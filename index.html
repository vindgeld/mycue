<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kolsotCam</title>
    <link rel="icon" type="image/x-icon" href="1.jpg">
    <style>
      :root{--bgclr:#021526;--txtclr:silver;--lst:#1E3E62;--actfrme:yellow;}
      .dark{--bgclr:black;--txtclr:white;--lst:#333;--actfrme:maroon;}
      body {font-family:sans-serif;color:var(--txtclr);margin:0;padding:0;background:var(--bgclr);transition: background-color 0.3s, color 0.3s;}
      header {padding-left:1em;height:8vh;background:var(--lst);color:var(--txtclr);display:flex;justify-content:space-between;align-items:center;}
      .isi,.tog{position:fixed;right:0}
      .mpc{width:96vw;margin: 0 auto;background:transparent;padding:0;border-radius: 8px;}
      #video, #youtubePlayer {position:sticky;top:0;width: 100%;max-height: 360px;border-radius: 8px;background: #000;}
      .controls {position:sticky;top:100px;display:flex;justify-content: center;align-items: center;gap: 20px;}
      .play-btn {width:40px;height:40px;display:flex;justify-content:center;align-items:center;background-color: #1E3E62;border: 1px solid #0070d2;padding: 12px;font-size: 20px;border-radius: 8px;cursor: pointer;}
      .inputfile {width: 0.1px;height: 0.1px;opacity: 0;overflow: hidden;position: absolute;z-index: -1;}
      .inputfile + label {background-color: #1E3E62;color:silver;border: 1px solid #0070d2;padding:6px 14px;font-size: 16px;border-radius: 12px;cursor: pointer;}
      .formatted-time {font-size: 16px;color: #d0d0ff;margin-bottom: 4px;font-family: monospace;}
      #playerError {color: #ffb3b3;padding:8px;display:none}
      #youtubePlayer.hidden {display:none}
    </style>
  </head>
  <body>
    <div id="dashboard" class="dashboard">
      <header>
        <h2>kolsote</h2>
        <div class="tog"><img src="icon.png" alt="icon" height="46" width="50"></div>
        <div class="isi">
          <button onclick="createProject()">Create New Project</button>
          <input type="file" id="file-input" accept=".xlsx" style="display: none" />
        </div>
      </header>

      <div id="mpc" class="mpc">
        <div style="margin-bottom:10px;">
          <input type="file" id="videoInput" class="inputfile" accept="video/*" />
          <label for="videoInput"><span>Choose video</span></label>
          <input type="text" id="youtubeURL" placeholder="YouTube link or id" />
          <button id="loadYoutubeBtn">Load YouTube</button>
        </div>

        <video id="video" controls></video>
        <div id="youtubePlayer" class="hidden"></div>

        <div id="playerError"></div>

        <div class="controls">
          <button id="playBtn" class="play-btn">â–¶</button>
          <button id="prevBtn">Prev</button>
          <button id="nextBtn">Next</button>
          <div class="time-inputs">
            <div class="time-block">
              <div id="startDisplay" class="formatted-time">00:00.0</div>
              <input type="number" id="startMin" min="0" value="0" step="1" />
              <input type="number" id="startSec" min="0" max="59.9" value="0" step="0.1" />
            </div>
            <div class="time-block">
              <div id="endDisplay" class="formatted-time">00:10.0</div>
              <input type="number" id="endMin" min="0" value="0" step="1" />
              <input type="number" id="endSec" min="0" max="59.9" value="10" step="0.1" />
            </div>
          </div>
        </div>

        <div id="listnya" class="listnya full"><ul id="segment-list" class="segment-list"></ul></div>
        <div id="total-time" style="z-index:4;font-weight: bold;"></div>
      </div>

      <!-- Modal simplified -->
      <div id="modal" class="modal hidden">
        <h3>Add New Segment</h3>
        <label for="segment-number">Number:</label>
        <input type="number" id="segment-number" placeholder="Enter number"><br>
        <label for="segment-title">Title:</label>
        <input type="text" id="segment-title" placeholder="Enter title"><br>
        <label for="segment-remarks">Remarks:</label>
        <textarea id="segment-remarks" rows="3" cols="32" placeholder="Enter remarks"></textarea><br>
        <label for="segment-duration">Duration (s):</label>
        <input type="number" id="segment-duration" placeholder="Enter duration in seconds"><br>
        <label for="segment-color">Color:</label>
        <input type="color" id="segment-color" value="#00ff00"><br><br>
        <button onclick="saveSegment()">Save Segment</button>
        <button class="close" onclick="closeModal()">Close</button>
      </div>
    </div>

    <!-- Load YouTube IFrame API -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
      // Simple app state
      let projects = JSON.parse(localStorage.getItem('projects') || '[]');
      let activeProjectId = null;
      let activeSegmentIndex = 0;
      let currentPlayerType = null; // 'html5' or 'youtube'
      let html5Adapter = null;
      let ytAdapter = null;
      let segmentController = null;

      // Basic project functions (simplified)
      function saveProjects() { localStorage.setItem('projects', JSON.stringify(projects)); }
      function renderProjects() { /* omitted for brevity in this patch */ }
      function createProject(){ const name = prompt('Enter project name'); if(!name) return; const id=Date.now(); projects.push({id,name,segments:[]}); saveProjects(); }

      // Utility: extract YouTube video id from URL or accept ID
      function extractYouTubeID(urlOrId) {
        if(!urlOrId) return null;
        const urlMatch = urlOrId.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/);
        if (urlMatch) return urlMatch[1];
        // if input looks like 11-char id
        if (/^[0-9A-Za-z_-]{11}$/.test(urlOrId)) return urlOrId;
        return null;
      }

      // --- Player adapters & SegmentController (from earlier recommendations) ---
      class EventEmitter { constructor(){ this.handlers = {}; } on(evt, fn){ (this.handlers[evt] ||= []).push(fn); } off(evt, fn){ if(!this.handlers[evt]) return; this.handlers[evt]=this.handlers[evt].filter(f=>f!==fn); } emit(evt,...args){ (this.handlers[evt]||[]).forEach(f=>f(...args)); } }

      class HTML5VideoPlayer extends EventEmitter {
        constructor(videoEl){ super(); this.video = videoEl; this._onTime = ()=> this.emit('timeupdate', this.getCurrentTime()); this._onPlay = ()=> this.emit('play'); this._onPause = ()=> this.emit('pause'); this._onSeeked = ()=> this.emit('seeked'); this._onWaiting = ()=> this.emit('buffering'); this._onPlaying = ()=> this.emit('playing'); this._onError = ()=> this.emit('error', this.video.error);
          this.video.addEventListener('timeupdate', this._onTime);
          this.video.addEventListener('play', this._onPlay);
          this.video.addEventListener('pause', this._onPause);
          this.video.addEventListener('seeked', this._onSeeked);
          this.video.addEventListener('waiting', this._onWaiting);
          this.video.addEventListener('playing', this._onPlaying);
          this.video.addEventListener('error', this._onError);
        }
        play(){ return this.video.play(); }
        pause(){ return this.video.pause(); }
        seek(sec){ return new Promise((resolve)=>{ const onSeek=()=>{ this.video.removeEventListener('seeked', onSeek); resolve(); }; this.video.addEventListener('seeked', onSeek); try{ this.video.currentTime = Math.max(0, sec); }catch(e){ resolve(); } setTimeout(resolve,1500); }); }
        getCurrentTime(){ return this.video.currentTime || 0; }
        destroy(){ this.video.removeEventListener('timeupdate', this._onTime); this.video.removeEventListener('play', this._onPlay); this.video.removeEventListener('pause', this._onPause); this.video.removeEventListener('seeked', this._onSeeked); this.video.removeEventListener('waiting', this._onWaiting); this.video.removeEventListener('playing', this._onPlaying); this.video.removeEventListener('error', this._onError); }
      }

      class YouTubePlayerAdapter extends EventEmitter {
        constructor(containerId){ super(); this.containerId = containerId; this.player = null; this.ready = false; }
        async create(videoId, playerVars = {playsinline:1,modestbranding:1,rel:0}){
          return new Promise((resolve, reject)=>{
            const createNow = ()=>{
              try{
                this.player = new YT.Player(this.containerId, {
                  videoId,
                  playerVars,
                  events: {
                    onReady: ()=>{ this.ready = true; this.emit('ready'); resolve(this); },
                    onStateChange: (ev)=> this._handleState(ev),
                    onError: (ev)=> this.emit('error', ev.data)
                  }
                });
              }catch(e){ reject(e); }
            };
            if(window.YT && window.YT.Player) createNow(); else {
              // wait for YT API
              let ticks=0; const wait = setInterval(()=>{ ticks++; if(window.YT && window.YT.Player){ clearInterval(wait); createNow(); } if(ticks>50){ clearInterval(wait); reject(new Error('YouTube API not available')); } }, 100);
            }
          });
        }
        _handleState(ev){ const st = ev.data; switch(st){ case YT.PlayerState.PLAYING: this.emit('playing'); break; case YT.PlayerState.PAUSED: this.emit('pause'); break; case YT.PlayerState.BUFFERING: this.emit('buffering'); break; case YT.PlayerState.ENDED: this.emit('ended'); break; case YT.PlayerState.CUED: this.emit('cued'); break; } this.emit('stateChange', st); }
        play(){ if(this.player) this.player.playVideo(); }
        pause(){ if(this.player) this.player.pauseVideo(); }
        seek(sec, allowSeekAhead=true){ return new Promise((resolve)=>{ if(!this.player) return resolve(); try{ this.player.seekTo(sec, allowSeekAhead); const target=Number(sec); const timeout = Date.now()+3000; const check = ()=>{ const t = this.getCurrentTime(); if(Math.abs(t-target)<0.6 || Date.now()>timeout) resolve(); else setTimeout(check,150); }; setTimeout(check,120); }catch(e){ resolve(); } }); }
        getCurrentTime(){ try{ return (this.player && this.player.getCurrentTime) ? this.player.getCurrentTime() : 0; }catch(e){ return 0; } }
        destroy(){ try{ if(this.player && this.player.destroy) this.player.destroy(); }catch(e){} }
      }

      class SegmentController {
        constructor(player, opts={}){ this.player = player; this.onTick = opts.onTick || (()=>{}); this.onSegmentEnd = opts.onSegmentEnd || (()=>{}); this.pollInterval = opts.pollInterval || 100; this._running=false; this._timerId=null; this._tolerance = opts.tolerance || 0.15; this._pausedForBuffer=false; this._handleBuffering = ()=>{ this._pausedForBuffer=true; }; this._handlePlaying = ()=>{ this._pausedForBuffer=false; }; player.on && player.on('buffering', this._handleBuffering); player.on && player.on('playing', this._handlePlaying); }
        async playSegment(segment){ if(!segment) return; this.stop(); this._segment = segment; await this.player.seek(segment.start || 0); try{ await this.player.play(); }catch(e){} this._startPolling(); }
        _startPolling(){ this._running=true; this._pausedForBuffer=false; const tick = ()=>{ if(!this._running) return; const t = this.player.getCurrentTime(); const remaining = Math.max(0, (this._segment.end || (this._segment.start + (this._segment.duration||0))) - t); this.onTick({currentTime:t, remaining}); if(!this._pausedForBuffer && remaining <= this._tolerance){ this.onSegmentEnd(this._segment); this.stop(); return; } this._timerId = setTimeout(tick, this.pollInterval); }; tick(); }
        stop(){ this._running=false; if(this._timerId){ clearTimeout(this._timerId); this._timerId=null; } }
        destroy(){ this.stop(); this.player.off && this.player.off('buffering', this._handleBuffering); this.player.off && this.player.off('playing', this._handlePlaying); }
      }

      // --- Integration: wiring UI to adapters ---
      const videoEl = document.getElementById('video');
      const youtubeDiv = document.getElementById('youtubePlayer');
      const playBtn = document.getElementById('playBtn');
      const loadYoutubeBtn = document.getElementById('loadYoutubeBtn');
      const youtubeURL = document.getElementById('youtubeURL');
      const playerError = document.getElementById('playerError');

      // Initialize HTML5 adapter
      html5Adapter = new HTML5VideoPlayer(videoEl);

      // Helper to switch to HTML5 player
      function useHTML5Player(){ currentPlayerType = 'html5'; youtubeDiv.classList.add('hidden'); videoEl.classList.remove('hidden'); if(segmentController) segmentController.destroy(); segmentController = new SegmentController(html5Adapter, {
        onTick: ({currentTime, remaining}) => { document.getElementById('total-time').textContent = `Remaining: ${remaining.toFixed(1)}s`; document.getElementById('startDisplay').textContent = formatTime(currentTime); },
        onSegmentEnd: ()=>{ html5Adapter.pause(); }
      }); }

      // Helper to switch to YouTube player
      function useYouTubePlayer(adapter){ currentPlayerType = 'youtube'; videoEl.classList.add('hidden'); youtubeDiv.classList.remove('hidden'); if(segmentController) segmentController.destroy(); segmentController = new SegmentController(adapter, {
        onTick: ({currentTime, remaining}) => { document.getElementById('total-time').textContent = `Remaining: ${remaining.toFixed(1)}s`; document.getElementById('startDisplay').textContent = formatTime(currentTime); },
        onSegmentEnd: ()=>{ adapter.pause(); }
      }); }

      // Format time helper
      function formatTime(sec){ sec = Number(sec) || 0; const m = Math.floor(sec/60); const s = (sec%60).toFixed(1).padStart(4,'0'); return `${String(m).padStart(2,'0')}:${s}`; }

      // Load local video -> use HTML5 adapter
      document.getElementById('videoInput').addEventListener('change', (e)=>{
        const f = e.target.files && e.target.files[0]; if(!f) return; const url = URL.createObjectURL(f); videoEl.src = url; useHTML5Player(); playerError.style.display='none';
      });

      // Load YouTube button
      loadYoutubeBtn.addEventListener('click', async ()=>{
        const input = youtubeURL.value.trim(); const videoId = extractYouTubeID(input);
        if(!videoId){ playerError.textContent = 'Invalid YouTube link or id'; playerError.style.display='block'; return; }
        playerError.style.display='none';
        // destroy previous adapter if exists
        if(ytAdapter){ ytAdapter.destroy(); }
        ytAdapter = new YouTubePlayerAdapter('youtubePlayer');
        try{
          await ytAdapter.create(videoId, {playsinline:1,modestbranding:1,rel:0});
          useYouTubePlayer(ytAdapter);
          ytAdapter.on('error', (code)=>{
            const msg = mapYTError(code);
            playerError.textContent = `YouTube error (${code}): ${msg}`;
            playerError.style.display='block';
          });
        }catch(e){ playerError.textContent = 'Failed to initialize YouTube player: '+e.message; playerError.style.display='block'; }
      });

      function mapYTError(code){ switch(code){ case 2: return 'Invalid parameter.'; case 5: return 'HTML5 player error (video cannot be played).'; case 100: return 'Video not found (removed or private).'; case 101: case 150: return 'Embedding disabled by owner.'; default: return 'Unknown error.'; } }

      // Play button: play current segment using controller. We'll read start/end from inputs for this simple integration.
      playBtn.addEventListener('click', async ()=>{
        const start = Number(document.getElementById('startMin').value || 0)*60 + Number(document.getElementById('startSec').value || 0);
        const end = Number(document.getElementById('endMin').value || 0)*60 + Number(document.getElementById('endSec').value || 0);
        if(!segmentController){ playerError.textContent='No player initialized. Load a video or YouTube first.'; playerError.style.display='block'; return; }
        playerError.style.display='none';
        const seg = {start, end};
        await segmentController.playSegment(seg);
      });

      // Prev/Next simple stubs (can be wired to segment list)
      document.getElementById('prevBtn').addEventListener('click', ()=>{ if(!segmentController) return; /* implement prev logic */ });
      document.getElementById('nextBtn').addEventListener('click', ()=>{ if(!segmentController) return; /* implement next logic */ });

      // Utility: onYouTubeIframeAPIReady (ensures API ready hook exists)
      window.onYouTubeIframeAPIReady = function(){ console.log('YouTube IFrame API ready'); };

      // Expose a small API for debugging
      window._app = { html5Adapter, ytAdapter, segmentController };

    </script>
  </body>
</html>